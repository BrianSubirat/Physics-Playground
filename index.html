<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script type="importmap">
{
  "imports": {
    "config": "./config.js"
  }
}
</script>
<style>
body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: Arial, sans-serif; }
#canvas { width: 100%; height: 100vh; }
#controls {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(20,20,20,0.95);
    padding: 20px;
    border-radius: 15px;
    color: white;
    max-height: 80vh;
    overflow-y: auto;
    width: 200px;
    box-shadow: 0 4px 30px rgba(0,0,0,0.3);
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.15);
    transition: all 0.3s ease;
}

#controls:hover {
    box-shadow: 0 6px 40px rgba(76, 175, 80, 0.25);
    transform: translateY(-2px);
}

#fps {
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: rgba(0,0,0,0.5);
    color: #4CAF50;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    font-family: monospace;
}

#searchBox {
    width: 80%;
    margin: 10px auto;
    padding: 6px 10px;
    background: rgba(30,30,30,0.95);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 10px;
    color: white;
    font-size: 12px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

#searchBox:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.2);
}

#searchResults {
    position: absolute;
    top: 100px;
    left: 10px;
    width: 200px;
    background: rgba(30,30,30,0.98);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 10px;
    max-height: 250px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    backdrop-filter: blur(8px);
}

.searchResult {
    padding: 10px 15px;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 13px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
}

.searchResult:last-child {
    border-bottom: none;
}

.searchResult:hover {
    background: rgba(76, 175, 80, 0.15);
    padding-left: 20px;
}

select {
    appearance: none;
    background-image: linear-gradient(45deg, transparent 50%, #4CAF50 50%), 
                      linear-gradient(135deg, #4CAF50 50%, transparent 50%);
    background-position: calc(100% - 20px) calc(1em + 2px),
                        calc(100% - 15px) calc(1em + 2px);
    background-size: 5px 5px,
                    5px 5px;
    background-repeat: no-repeat;
    transition: all 0.3s ease;
    color: white;
}

select:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.2);
    background-color: rgba(40,40,40,0.95);
}

select:focus {
    transform: translateY(-2px);
    background-color: rgba(40,40,40,0.95);
}

select option {
    background: rgba(30,30,30,0.98);
    color: white;
    padding: 12px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
}

select option:hover {
    background: rgba(76, 175, 80, 0.15);
}

#objectSelect, #effectsSelect {
    padding: 12px 35px 12px 15px;
    margin: 10px 0;
    border-radius: 12px;
    background-color: rgba(30,30,30,0.95);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    border: 1px solid rgba(255,255,255,0.1);
}

#objectSelect:focus, #effectsSelect:focus {
    border-color: #4CAF50;
    outline: none;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
}

optgroup {
    background: rgba(20,20,20,0.98);
    color: #4CAF50;
    font-weight: bold;
    padding: 8px;
}

button {
    margin: 8px 0;
    width: 100%;
    padding: 8px 12px;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 10px;
    background: linear-gradient(to bottom right, #4CAF50, #45a049);
    color: white;
    font-size: 13px;
    transition: all 0.3s ease;
    cursor: pointer;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
    background: linear-gradient(to bottom right, #45a049, #409945);
}

h3 {
    color: #4CAF50;
    margin-bottom: 15px;
    text-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
}

.info {
    font-size: 10px;
    color: #aaa;
    margin-top: 5px;
    padding: 5px;
    border-left: 3px solid #555;
}

#updateNotes {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(20,20,20,0.95);
    padding: 20px;
    border-radius: 15px;
    color: white;
    max-width: 400px;
    width: 90%;
    box-shadow: 0 4px 30px rgba(0,0,0,0.3);
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.15);
    z-index: 1000;
}

#updateNotes h2 {
    color: #4CAF50;
    margin-bottom: 15px;
}

#updateNotes ul {
    list-style-type: none;
    padding: 0;
}

#updateNotes li {
    padding: 8px 0;
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

#updateNotes button {
    margin-top: 15px;
    width: auto;
    padding: 8px 20px;
}

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.7);
    z-index: 999;
}

.tooltip {
    position: absolute;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 1000;
}

.theme-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(30,30,30,0.7);
    color: white;
    border: none;
    width: auto;
    border-radius: 50%;
    height: 40px;
    width: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
}

.theme-toggle:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(255,255,255,0.15);
}

.theme-toggle svg {
    height: 20px;
    width: 20px;
    fill: white;
}

/* Dark theme is default */
.light-theme {
    background: #f5f5f5;
}

.light-theme #controls {
    background: rgba(255,255,255,0.95);
    color: #333;
    box-shadow: 0 4px 30px rgba(0,0,0,0.1);
    border: 1px solid rgba(0,0,0,0.1);
}

.light-theme h3 {
    color: #2E7D32;
}

.light-theme #searchBox,
.light-theme select,
.light-theme #searchResults {
    background: rgba(240,240,240,0.95);
    color: #333;
    border-color: rgba(0,0,0,0.1);
}

.light-theme .searchResult:hover {
    background: rgba(76, 175, 80, 0.1);
}

.light-theme .theme-toggle {
    background: rgba(240,240,240,0.7);
    color: #333;
}

.light-theme .theme-toggle svg {
    fill: #333;
}

.light-theme button {
    background: linear-gradient(to bottom right, #2E7D32, #388E3C);
}

.particles-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: -1;
}

.particle {
    position: absolute;
    background: rgba(76, 175, 80, 0.2);
    border-radius: 50%;
    pointer-events: none;
}

@media (max-width: 768px) {
    #controls {
        width: 180px;
        padding: 15px;
    }
    
    #searchBox, select, button {
        font-size: 12px;
        padding: 7px 10px;
    }
    
    #searchResults {
        width: 180px;
    }
}

@media (max-width: 480px) {
    #controls {
        width: 160px;
        padding: 12px;
    }
    
    #searchBox, select, button {
        font-size: 11px;
        padding: 6px 8px;
    }
    
    #searchResults {
        width: 160px;
    }
    
    .searchResult {
        padding: 8px 12px;
    }
}

canvas { 
  touch-action: none;
  cursor: grab !important;
}
canvas:active {
  cursor: grabbing !important;
}
</style>
</head>
<body>
<div id="controls">
    <h3>Physics Playground</h3>
    <input type="text" id="searchBox" placeholder="Search objects...">
    <div id="searchResults"></div>
    <select id="objectSelect">
        <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="triangle">Triangle</option>
            <option value="rectangle">Rectangle</option>
            <option value="pentagon">Pentagon</option>
            <option value="hexagon">Hexagon</option>
        </optgroup>
        <optgroup label="Special Objects">
            <option value="star">Star</option>
            <option value="gear">Gear</option>
            <option value="chain">Chain</option>
            <option value="rope">Rope</option>
            <option value="balloon">Balloon</option>
            <option value="boulder">Boulder</option>
        </optgroup>
        <optgroup label="Game Objects">
            <option value="plank">Wooden Plank</option>
            <option value="ball">Bouncy Ball</option>
            <option value="box">Heavy Box</option>
            <option value="pillar">Stone Pillar</option>
        </optgroup>
        <optgroup label="Mechanisms">
            <option value="spring">Spring</option>
            <option value="pendulum">Pendulum</option>
            <option value="seesaw">Seesaw</option>
            <option value="wheel">Wheel</option>
            <option value="platform">Platform</option>
        </optgroup>
        <optgroup label="Fun Items">
            <option value="domino">Domino</option>
            <option value="car">Car</option>
            <option value="cube">3D Cube</option>
            <option value="pyramid">Pyramid</option>
            <option value="bridge">Bridge Piece</option>
        </optgroup>
        <optgroup label="Weapons">
            <option value="hammer">Hammer</option>
            <option value="arrow">Arrow</option>
            <option value="bullet">Bullet</option>
            <option value="cannon">Cannon</option>
        </optgroup>
        <optgroup label="Characters">
            <option value="bird">Angry Bird</option>
            <option value="pig">Target Pig</option>
            <option value="human">Human</option>
        </optgroup>
        <optgroup label="Power-Ups">
            <option value="tnt">TNT Box</option>
            <option value="magnet">Magnet</option>
            <option value="portal">Portal</option>
            <option value="fan">Fan</option>
        </optgroup>
        <optgroup label="Elements">
            <option value="water">Water (Liquid)</option>
            <option value="fire">Fire Particle</option>
            <option value="smoke">Smoke</option>
            <option value="ice">Ice Block</option>
            <option value="cloud">Cloud</option>
            <option value="lightning">Lightning Bolt</option>
        </optgroup>
        <optgroup label="Special Effects">
            <option value="bomb">Bomb</option>
            <option value="coin">Coin</option>
            <option value="crystal">Crystal</option>
            <option value="blade">Spinning Blade</option>
            <option value="trampoline">Trampoline</option>
            <option value="antigravity">Anti-Gravity Field</option>
            <option value="blackhole">Black Hole</option>
            <option value="forcefield">Force Field</option>
        </optgroup>
    </select>
    <h3>Effects</h3>
    <select id="effectsSelect">
        <optgroup label="Special Effects">
            <option value>Special Effects</option>
            <option value="lightning_bolt">&#x26a1; Lightning Strike</option>
            <option value="fire_source">&#x1f525; Fire Source</option> 
        </optgroup>
    </select>
    <button onclick="spawnObject()">Spawn Object</button>
    <button onclick="clearObjects()">Clear All</button>
    <div class="info">Click and drag to move objects</div>
    <div class="info">Right-click to delete objects</div>
    <div class="info">Hold mouse button to use effects</div>
</div>
<div id="canvas"></div>
<div id="fps">FPS: 60</div>
<button class="theme-toggle" onclick="toggleTheme()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13h2c0.55,0,1-0.45,1-1s-0.45-1-1-1H2c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13h2c0.55,0,1-0.45,1-1 s-0.45-1-1-1h-2c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1S11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/>
    </svg>
</button>
<div class="particles-container"></div>
<div class="tooltip"></div>

<script type="module">
import * as config from 'config';

const Engine = Matter.Engine,
  Render = Matter.Render,
  Runner = Matter.Runner,
  Bodies = Matter.Bodies,
  Composite = Matter.Composite,
  Mouse = Matter.Mouse,
  MouseConstraint = Matter.MouseConstraint,
  Body = Matter.Body,
  Vector = Matter.Vector,
  Vertices = Matter.Vertices;

const PARTICLE_SIZE = 6;
const LIQUID_DENSITY = 0.01;
const LIQUID_FRICTION = 0.1;
const LIQUID_FRICTION_AIR = 0.0001;
const LIQUID_RESTITUTION = 0.2;
const STIFFNESS = 0.5;
const DAMPING = 0.1;

let hasSeenUpdateNotes = false;

const engine = Engine.create({
  enableSleeping: true,
  constraintIterations: 2,
  positionIterations: 6,
  velocityIterations: 4
});

engine.world.gravity.y = 1.5;
engine.world.gravity.scale = 0.002;
engine.timing.timeScale = 1.0;

const render = Render.create({
  element: document.querySelector("#canvas"),
  engine: engine,
  options: {
    width: window.innerWidth,
    height: window.innerHeight,
    wireframes: false,
    background: '#1a1a1a'
  }
});

const runner = Runner.create();
Runner.run(runner, engine);
Render.run(render);

const mouse = Mouse.create(render.canvas);
let mouseConstraint = MouseConstraint.create(engine, {
  mouse: mouse,
  constraint: {
    stiffness: 0.2,
    render: {
      visible: false
    },
    angularStiffness: 0.1,
    damping: 0.1
  },
  collisionFilter: {
    mask: 0xFFFFFFFF
  }
});

Composite.add(engine.world, mouseConstraint);

render.mouse = mouse;

const walls = [Bodies.rectangle(window.innerWidth / 2, window.innerHeight + 30, window.innerWidth, 60, {
  isStatic: true,
  restitution: 0.4,
  friction: 0.8
}), Bodies.rectangle(window.innerWidth / 2, -30, window.innerWidth, 60, {
  isStatic: true,
  restitution: 0.4,
  friction: 0.8
}), Bodies.rectangle(-30, window.innerHeight / 2, 60, window.innerHeight, {
  isStatic: true,
  restitution: 0.4,
  friction: 0.8
}), Bodies.rectangle(window.innerWidth + 30, window.innerHeight / 2, 60, window.innerHeight, {
  isStatic: true,
  restitution: 0.4,
  friction: 0.8
})];

Composite.add(engine.world, walls);

function getRandomColor() {
  const colors = ['#f55', '#5f5', '#55f', '#ff5', '#f5f', '#5ff'];
  return colors[Math.floor(Math.random() * colors.length)];
}

function spawnObject() {
  const type = document.getElementById('objectSelect').value;
  const x = Math.random() * (window.innerWidth - 100) + 50;
  const y = Math.random() * (window.innerHeight - 100) + 50;
  let body;

  const defaultOptions = {
    restitution: 0.4,
    friction: 0.8,
    density: 0.001,
    render: {
      fillStyle: getRandomColor()
    }
  };

  switch (type) {
    case 'circle':
      body = Bodies.circle(x, y, 25, defaultOptions);
      break;
    case 'square':
      body = Bodies.rectangle(x, y, 50, 50, defaultOptions);
      break;
    case 'triangle':
      body = Bodies.polygon(x, y, 3, 30, defaultOptions);
      break;
    case 'rectangle':
      body = Bodies.rectangle(x, y, 80, 40, defaultOptions);
      break;
    case 'pentagon':
      body = Bodies.polygon(x, y, 5, 30, defaultOptions);
      break;
    case 'hexagon':
      body = Bodies.polygon(x, y, 6, 30, defaultOptions);
      break;
    case 'star':
      const starPath = starVertices(30);
      body = Bodies.fromVertices(x, y, starPath, {
        ...defaultOptions,
        render: {
          fillStyle: '#FFD700'
        }
      });
      break;
    case 'gear':
      body = createGear(x, y, 40, 12);
      break;
    case 'chain':
      createChain(x, y);
      return;
    case 'rope':
      createRope(x, y);
      return;
    case 'spring':
      createSpring(x, y);
      return;
    case 'pendulum':
      createPendulum(x, y);
      return;
    case 'seesaw':
      createSeesaw(x, y);
      return;
    case 'wheel':
      body = Bodies.circle(x, y, 40, {
        ...defaultOptions,
        render: {
          fillStyle: '#444',
          lineWidth: 3,
          strokeStyle: '#666'
        }
      });
      break;
    case 'platform':
      body = Bodies.rectangle(x, y, 200, 20, {
        ...defaultOptions,
        isStatic: true,
        render: {
          fillStyle: '#666'
        }
      });
      break;
    case 'domino':
      body = Bodies.rectangle(x, y, 10, 50, {
        ...defaultOptions,
        density: 0.001,
        render: {
          fillStyle: '#fff'
        }
      });
      break;
    case 'car':
      createCar(x, y);
      return;
    case 'cube':
      body = createCube(x, y);
      break;
    case 'pyramid':
      body = createPyramid(x, y);
      break;
    case 'bridge':
      body = Bodies.rectangle(x, y, 100, 20, {
        ...defaultOptions,
        render: {
          fillStyle: '#8B4513'
        }
      });
      break;
    case 'hammer':
      body = createHammer(x, y);
      break;
    case 'arrow':
      body = createArrow(x, y);
      break;
    case 'bullet':
      body = Bodies.circle(x, y, 5, {
        ...defaultOptions,
        density: 0.002,
        restitution: 0.1,
        render: {
          fillStyle: '#FFD700'
        }
      });
      break;
    case 'cannon':
      createCannon(x, y);
      return;
    case 'bird':
      body = Bodies.circle(x, y, 25, {
        ...defaultOptions,
        render: {
          fillStyle: '#ff0000'
        }
      });
      break;
    case 'pig':
      body = Bodies.circle(x, y, 30, {
        ...defaultOptions,
        render: {
          fillStyle: '#90EE90'
        }
      });
      break;
    case 'tnt':
      body = Bodies.rectangle(x, y, 40, 40, {
        ...defaultOptions,
        render: {
          fillStyle: '#ff0000'
        }
      });
      break;
    case 'magnet':
      body = createMagnet(x, y);
      break;
    case 'portal':
      createPortalPair(x, y);
      return;
    case 'fan':
      body = createFan(x, y);
      break;
    case 'water':
      createLiquidParticles(x, y, 8);
      return;
    case 'fire':
      body = createFireParticle(x, y);
      break;
    case 'smoke':
      body = Bodies.circle(x, y, 10, {
        ...defaultOptions,
        density: 0.00001,
        frictionAir: 0.01,
        render: {
          fillStyle: '#8884'
        }
      });
      break;
    case 'ice':
      body = Bodies.rectangle(x, y, 40, 40, {
        ...defaultOptions,
        friction: 0.01,
        restitution: 0.4,
        density: 0.001,
        render: {
          fillStyle: '#add8e6'
        }
      });
      break;
    case 'cloud':
      body = createCloud(x, y);
      break;
    case 'lightning':
      body = createLightning(x, y);
      break;
    case 'bomb':
      body = createBomb(x, y);
      break;
    case 'coin':
      body = Bodies.circle(x, y, 15, {
        ...defaultOptions,
        render: {
          fillStyle: '#FFD700'
        }
      });
      break;
    case 'crystal':
      body = createCrystal(x, y);
      break;
    case 'blade':
      createSpinningBlade(x, y);
      return;
    case 'trampoline':
      createTrampoline(x, y);
      return;
    case 'antigravity':
      createAntiGravityField(x, y);
      return;
    case 'blackhole':
      createBlackHole(x, y);
      return;
    case 'forcefield':
      createForceField(x, y);
      return;
    case 'human':
      createHuman(x, y);
      return;
    case 'fire_source':
      return;
    case 'boulder':
      const boulderVertices = [];
      const boulderRadius = 30;
      const boulderSegments = 12;
      for (let i = 0; i < boulderSegments; i++) {
        const angle = Math.PI * 2 * i / boulderSegments;
        const radius = boulderRadius * (0.8 + Math.random() * 0.4);
        boulderVertices.push({
          x: radius * Math.cos(angle),
          y: radius * Math.sin(angle)
        });
      }
      body = Bodies.fromVertices(x, y, boulderVertices, {
        render: {
          fillStyle: '#7c7169',
          strokeStyle: '#5c514a',
          lineWidth: 2
        },
        density: 0.002,
        friction: 0.7,
        restitution: 0.3
      });
      break;
    default:
      body = Bodies.circle(x, y, 25, defaultOptions);
  }

  if (!body && type !== 'fire_source' && type !== 'lightning_bolt') {
    body = Bodies.circle(x, y, 25, defaultOptions);
  }

  if (body) {
    Composite.add(engine.world, body);
  }
}

function starVertices(size) {
  const points = [];
  for (let i = 0; i < 10; i++) {
    const radius = i % 2 === 0 ? size : size / 2;
    const angle = Math.PI * 2 * i / 10;
    points.push({
      x: radius * Math.cos(angle),
      y: radius * Math.sin(angle)
    });
  }
  return points;
}

function createGear(x, y, radius, teeth) {
  const vertices = [];
  for (let i = 0; i < teeth * 2; i++) {
    const angle = Math.PI * 2 * i / (teeth * 2);
    const r = i % 2 === 0 ? radius : radius * 0.8;
    vertices.push({
      x: r * Math.cos(angle),
      y: r * Math.sin(angle)
    });
  }
  return Bodies.fromVertices(x, y, vertices, {
    render: {
      fillStyle: '#888'
    },
    density: 0.001
  });
}

function createChain(x, y) {
  const group = Body.nextGroup(true);
  const links = 10;
  let previousBody = null;
  for (let i = 0; i < links; i++) {
    const body = Bodies.rectangle(x, y + i * 20, 20, 10, {
      collisionFilter: {
        group: group
      },
      render: {
        fillStyle: '#666'
      }
    });
    if (previousBody) {
      const constraint = Matter.Constraint.create({
        bodyA: previousBody,
        bodyB: body,
        stiffness: 0.8
      });
      Composite.add(engine.world, constraint);
    }
    Composite.add(engine.world, body);
    previousBody = body;
  }
}

function createRope(x, y) {
  const group = Body.nextGroup(true);
  const length = 10;
  let previousBody = null;
  for (let i = 0; i < length; i++) {
    const body = Bodies.circle(x, y + i * 20, 10, {
      collisionFilter: {
        group: group
      },
      render: {
        fillStyle: '#ccc'
      }
    });
    if (previousBody) {
      const constraint = Matter.Constraint.create({
        bodyA: previousBody,
        bodyB: body,
        stiffness: 0.8,
        length: 20
      });
      Composite.add(engine.world, constraint);
    }
    Composite.add(engine.world, body);
    previousBody = body;
  }
}

function createSpring(x, y) {
  const bodyA = Bodies.circle(x, y, 20, {
    render: {
      fillStyle: '#f00'
    },
    density: 0.002,
    restitution: 0.3
  });
  const bodyB = Bodies.circle(x, y + 100, 20, {
    render: {
      fillStyle: '#0f0'
    },
    density: 0.002,
    restitution: 0.3
  });
  const constraint = Matter.Constraint.create({
    bodyA: bodyA,
    bodyB: bodyB,
    stiffness: 0.05,
    damping: 0.1,
    length: 100
  });
  Composite.add(engine.world, [bodyA, bodyB, constraint]);
}

function createPendulum(x, y) {
  const body = Bodies.circle(x, y, 20, {
    render: {
      fillStyle: '#f00'
    }
  });
  const pivot = Bodies.circle(x, y - 100, 10, {
    isStatic: true,
    render: {
      fillStyle: '#0f0'
    }
  });
  const constraint = Matter.Constraint.create({
    bodyA: pivot,
    bodyB: body,
    stiffness: 0.1,
    length: 100
  });
  Composite.add(engine.world, [body, pivot, constraint]);
}

function createSeesaw(x, y) {
  const bodyA = Bodies.circle(x - 50, y, 20, {
    render: {
      fillStyle: '#f00'
    }
  });
  const bodyB = Bodies.circle(x + 50, y, 20, {
    render: {
      fillStyle: '#0f0'
    }
  });
  const pivot = Bodies.circle(x, y - 100, 10, {
    isStatic: true,
    render: {
      fillStyle: '#00f'
    }
  });
  const constraintA = Matter.Constraint.create({
    bodyA: pivot,
    bodyB: bodyA,
    stiffness: 0.1,
    length: 100
  });
  const constraintB = Matter.Constraint.create({
    bodyA: pivot,
    bodyB: bodyB,
    stiffness: 0.1,
    length: 100
  });
  Composite.add(engine.world, [bodyA, bodyB, pivot, constraintA, constraintB]);
}

function createCar(x, y) {
  const body = Bodies.rectangle(x, y, 100, 20, {
    render: {
      fillStyle: '#777'
    }
  });
  const wheelA = Bodies.circle(x - 40, y + 20, 10, {
    render: {
      fillStyle: '#f00'
    }
  });
  const wheelB = Bodies.circle(x + 40, y + 20, 10, {
    render: {
      fillStyle: '#0f0'
    }
  });
  const constraintA = Matter.Constraint.create({
    bodyA: body,
    bodyB: wheelA,
    stiffness: 0.1,
    length: 20
  });
  const constraintB = Matter.Constraint.create({
    bodyA: body,
    bodyB: wheelB,
    stiffness: 0.1,
    length: 20
  });
  Composite.add(engine.world, [body, wheelA, wheelB, constraintA, constraintB]);
}

function createCube(x, y) {
  const body = Bodies.rectangle(x, y, 50, 50, {
    render: {
      fillStyle: '#888'
    }
  });
  return body;
}

function createPyramid(x, y) {
  const vertices = [];
  vertices.push({
    x: -25,
    y: 25
  });
  vertices.push({
    x: 25,
    y: 25
  });
  vertices.push({
    x: 0,
    y: -25
  });
  const body = Bodies.fromVertices(x, y, vertices, {
    render: {
      fillStyle: '#ccc'
    }
  });
  return body;
}

function createHammer(x, y) {
  const body = Bodies.rectangle(x, y, 20, 50, {
    render: {
      fillStyle: '#777'
    }
  });
  const head = Bodies.circle(x, y + 60, 20, {
    render: {
      fillStyle: '#f00'
    }
  });
  const constraint = Matter.Constraint.create({
    bodyA: body,
    bodyB: head,
    stiffness: 0.1,
    length: 60
  });
  Composite.add(engine.world, [body, head, constraint]);
  return body;
}

function createArrow(x, y) {
  const body = Bodies.rectangle(x, y, 10, 50, {
    render: {
      fillStyle: '#ccc'
    }
  });
  const head = Bodies.polygon(x, y + 60, 3, 15, {
    render: {
      fillStyle: '#f00'
    }
  });
  const constraint = Matter.Constraint.create({
    bodyA: body,
    bodyB: head,
    stiffness: 0.1,
    length: 60
  });
  Composite.add(engine.world, [body, head, constraint]);
  return body;
}

function createMagnet(x, y) {
  const body = Bodies.circle(x, y, 20, {
    render: {
      fillStyle: '#00f'
    }
  });
  return body;
}

function createFireParticle(x, y) {
  const colors = ['#ff4400', '#ff8800', '#ffaa00', '#ff0000'];
  const size = Math.random() * 6 + 2;
  const lifetime = Math.random() * 800 + 400;
  const body = Bodies.circle(x, y, size, {
    render: {
      fillStyle: colors[Math.floor(Math.random() * colors.length)]
    },
    frictionAir: 0.1,
    density: 0.0001,
    isStatic: false,
    collisionFilter: {
      group: -1,
      category: 0x0002,
      mask: 0x0001
    }
  });
  Body.setVelocity(body, {
    x: (Math.random() - 0.5) * 3,
    y: -4 * Math.random() - 2
  });
  Composite.add(engine.world, body);
  setTimeout(() => {
    Composite.remove(engine.world, body);
  }, lifetime);
  return body;
}

function createCrystal(x, y) {
  const vertices = [];
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI * 2 * i / 6;
    vertices.push({
      x: 20 * Math.cos(angle),
      y: 20 * Math.sin(angle)
    });
  }
  const body = Bodies.fromVertices(x, y, vertices, {
    render: {
      fillStyle: '#ccc'
    }
  });
  return body;
}

function createPortalPair(x, y) {
  const portalA = Bodies.circle(x - 50, y, 20, {
    render: {
      fillStyle: '#00f'
    }
  });
  const portalB = Bodies.circle(x + 50, y, 20, {
    render: {
      fillStyle: '#f00'
    }
  });
  Composite.add(engine.world, [portalA, portalB]);
}

function createFan(x, y) {
  const base = Bodies.rectangle(x, y, 40, 60, {
    isStatic: true,
    render: {
      fillStyle: '#888'
    }
  });
  const blade = Bodies.rectangle(x, y - 30, 80, 10, {
    density: 0.0001,
    render: {
      fillStyle: '#666'
    }
  });
  const pivot = Matter.Constraint.create({
    bodyA: base,
    bodyB: blade,
    pointA: {
      x: 0,
      y: -30
    },
    pointB: {
      x: 0,
      y: 0
    },
    stiffness: 1,
    length: 0
  });
  Matter.Events.on(engine, 'beforeUpdate', () => {
    if (blade) {
      Body.setAngularVelocity(blade, 0.2);
    }
  });
  Composite.add(engine.world, [base, blade, pivot]);
  return base;
}

function createCloud(x, y) {
  const group = Body.nextGroup(true);
  const circles = [];
  for (let i = 0; i < 5; i++) {
    circles.push(Bodies.circle(x + (i - 2) * 15, y + (Math.random() - 0.5) * 10, 20 + Math.random() * 10, {
      render: {
        fillStyle: '#fff',
        opacity: 0.8
      },
      density: 0.0001,
      frictionAir: 0.05,
      collisionFilter: {
        group: group
      }
    }));
  }
  Composite.add(engine.world, circles);
  for (let i = 0; i < circles.length - 1; i++) {
    const constraint = Matter.Constraint.create({
      bodyA: circles[i],
      bodyB: circles[i + 1],
      stiffness: 0.4,
      render: {
        visible: false
      }
    });
    Composite.add(engine.world, constraint);
  }
  return circles[0];
}

function createLightning(x, y) {
  const segments = 12;
  const segmentLength = 15;
  let prevBody = null;
  const group = Body.nextGroup(true);
  const points = [{
    x,
    y
  }];
  for (let i = 1; i <= segments; i++) {
    points.push({
      x: x + (Math.random() - 0.5) * 40,
      y: y + i * segmentLength
    });
  }
  for (let i = 0; i < points.length - 1; i++) {
    const start = points[i];
    const end = points[i + 1];
    const angle = Math.atan2(end.y - start.y, end.x - start.x);
    const length = Vector.magnitude(Vector.sub(end, start));
    const body = Bodies.rectangle((start.x + end.x) / 2, (start.y + end.y) / 2, length, 3, {
      angle: angle,
      render: {
        fillStyle: '#ffff00',
        strokeStyle: '#ffffff',
        lineWidth: 1
      },
      collisionFilter: {
        group
      },
      density: 0.0001,
      frictionAir: 0.01
    });
    if (prevBody) {
      const constraint = Matter.Constraint.create({
        bodyA: prevBody,
        bodyB: body,
        stiffness: 0.9,
        render: {
          visible: false
        }
      });
      Composite.add(engine.world, constraint);
    }
    prevBody = body;
    Composite.add(engine.world, body);
    for (let j = 0; j < 2; j++) {
      const particle = Bodies.circle(body.position.x + (Math.random() - 0.5) * 10, body.position.y + (Math.random() - 0.5) * 10, 2, {
        render: {
          fillStyle: '#ffffff80'
        },
        collisionFilter: {
          group
        }
      });
      Composite.add(engine.world, particle);
    }
  }
  setTimeout(() => {
    const bodies = Composite.allBodies(engine.world);
    bodies.forEach(body => {
      if (body.collisionFilter.group === group) {
        Composite.remove(engine.world, body);
      }
    });
  }, 1000);
}

function createBomb(x, y) {
  const body = Bodies.circle(x, y, 25, {
    label: 'bomb',
    render: {
      fillStyle: '#000',
      strokeStyle: '#ff0000',
      lineWidth: 3
    }
  });
  setTimeout(() => {
    createExplosion(body.position.x, body.position.y);
    Composite.remove(engine.world, body);
  }, 3000);
  return body;
}

function createSpinningBlade(x, y) {
  const blade = Bodies.rectangle(x, y, 100, 10, {
    render: {
      fillStyle: '#888',
      strokeStyle: '#666',
      lineWidth: 1
    }
  });
  const pivot = Bodies.circle(x, y, 5, {
    isStatic: true,
    render: {
      fillStyle: '#666'
    }
  });
  const constraint = Matter.Constraint.create({
    bodyA: blade,
    bodyB: pivot,
    pointB: {
      x: 0,
      y: 0
    },
    stiffness: 1,
    length: 0
  });
  Matter.Events.on(engine, 'beforeUpdate', () => {
    Body.setAngularVelocity(blade, 0.2);
  });
  Composite.add(engine.world, [blade, pivot, constraint]);
}

function createTrampoline(x, y) {
  const body = Bodies.rectangle(x, y, 100, 20, {
    render: {
      fillStyle: '#0f0'
    }
  });
  return body;
}

function createAntiGravityField(x, y) {
  const body = Bodies.circle(x, y, 20, {
    render: {
      fillStyle: '#00f'
    }
  });
  return body;
}

function createBlackHole(x, y) {
  const body = Bodies.circle(x, y, 20, {
    render: {
      fillStyle: '#000'
    }
  });
  return body;
}

function createForceField(x, y) {
  const body = Bodies.circle(x, y, 20, {
    render: {
      fillStyle: '#f0f'
    }
  });
  return body;
}

function createExplosion(x, y) {
  const particles = 50;
  const radius = 600;
  const force = 0.12;
  for (let i = 0; i < particles; i++) {
    const angle = Math.PI * 2 / particles * i;
    const velocity = 25;
    const size = Math.random() * 12 + 5;
    const lifetime = Math.random() * 2000 + 1000;
    const colors = ['#ff4400', '#ff8800', '#ffaa00', '#ff0000'];
    const particle = Bodies.circle(x, y, size, {
      render: {
        fillStyle: colors[Math.floor(Math.random() * colors.length)]
      },
      frictionAir: 0.05,
      isStatic: false
    });
    Body.setVelocity(particle, {
      x: Math.cos(angle) * velocity * (Math.random() + 0.5),
      y: Math.sin(angle) * velocity * (Math.random() + 0.5)
    });
    Composite.add(engine.world, particle);
    setTimeout(() => {
      Composite.remove(engine.world, particle);
    }, lifetime);
  }
  for (let i = 0; i < 20; i++) {
    setTimeout(() => {
      createFireParticle(x + (Math.random() - 0.5) * 80, y + (Math.random() - 0.5) * 80);
    }, i * 100);
  }
  const bodies = Composite.allBodies(engine.world);
  bodies.forEach(body => {
    if (body.label !== 'bomb') {
      const distance = Vector.magnitude(Vector.sub(body.position, {
        x,
        y
      }));
      if (distance < radius) {
        const forceMagnitude = force * (1 - distance / radius);
        const forceVector = Vector.mult(Vector.normalise(Vector.sub(body.position, {
          x,
          y
        })), forceMagnitude);
        Body.applyForce(body, {
          x,
          y
        }, forceVector);
      }
    }
  });
}

function clearObjects() {
  const bodies = Composite.allBodies(engine.world);
  const constraints = Composite.allConstraints(engine.world);
  Matter.Events.off(engine, 'beforeUpdate');
  bodies.forEach(body => {
    if (!body.isStatic) {
      Composite.remove(engine.world, body);
    }
  });
  constraints.forEach(constraint => {
    if (constraint !== mouseConstraint && (!constraint.bodyA?.isStatic || !constraint.bodyB?.isStatic)) {
      Composite.remove(engine.world, constraint);
    }
  });
  recreateMouseConstraint();
}

function createLiquidParticles(x, y, count) {
  const group = Body.nextGroup(true);
  const particles = [];
  const maxParticles = Math.min(count, 12);
  for (let i = 0; i < maxParticles; i++) {
    const particle = Bodies.circle(x + (Math.random() - 0.5) * 20, y + (Math.random() - 0.5) * 20, PARTICLE_SIZE, {
      collisionFilter: {
        group
      },
      render: {
        fillStyle: '#00f4',
        opacity: 0.6
      },
      density: LIQUID_DENSITY,
      friction: LIQUID_FRICTION,
      frictionAir: LIQUID_FRICTION_AIR,
      restitution: LIQUID_RESTITUTION
    });
    particles.push(particle);
  }
  for (let i = 0; i < particles.length; i++) {
    for (let j = i + 1; j < particles.length; j++) {
      if (Vector.magnitude(Vector.sub(particles[i].position, particles[j].position)) < PARTICLE_SIZE * 4) {
        const constraint = Matter.Constraint.create({
          bodyA: particles[i],
          bodyB: particles[j],
          stiffness: STIFFNESS,
          damping: DAMPING,
          render: {
            visible: false
          }
        });
        Composite.add(engine.world, constraint);
      }
    }
  }
  Composite.add(engine.world, particles);
  Matter.Events.on(engine, 'afterUpdate', () => {
    particles.forEach(particle => {
      const velY = particle.velocity.y;
      Body.applyForce(particle, particle.position, {
        x: 0,
        y: -0.00001 * velY * velY * (velY > 0 ? 1 : -1)
      });
      particles.forEach(other => {
        if (particle !== other) {
          const dist = Vector.magnitude(Vector.sub(particle.position, other.position));
          if (dist < PARTICLE_SIZE * 4) {
            const force = 0.0000005 * (1 - dist / (PARTICLE_SIZE * 4));
            Body.applyForce(particle, particle.position, Vector.mult(Vector.normalise(Vector.sub(other.position, particle.position)), force));
          }
        }
      });
    });
  });
}

function createHuman(x, y) {
  const group = Body.nextGroup(true);
  const head = Bodies.circle(x, y - 30, 15, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#FFE0BD'
    },
    density: 0.002,
    friction: 0.5
  });
  const torso = Bodies.rectangle(x, y + 10, 30, 40, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#4A90E2'
    },
    density: 0.003,
    friction: 0.5
  });
  const pelvis = Bodies.rectangle(x, y + 35, 25, 15, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#3A80D2'
    },
    density: 0.002,
    friction: 0.5
  });
  const upperLeftArm = Bodies.rectangle(x - 22, y - 5, 20, 8, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#FFE0BD'
    },
    density: 0.001,
    friction: 0.3
  });
  const lowerLeftArm = Bodies.rectangle(x - 35, y - 5, 20, 6, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#FFE0BD'
    },
    density: 0.001,
    friction: 0.3
  });
  const upperRightArm = Bodies.rectangle(x + 22, y - 5, 20, 8, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#FFE0BD'
    },
    density: 0.001,
    friction: 0.3
  });
  const lowerRightArm = Bodies.rectangle(x + 35, y - 5, 20, 6, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#FFE0BD'
    },
    density: 0.001,
    friction: 0.3
  });
  const upperLeftLeg = Bodies.rectangle(x - 10, y + 50, 8, 20, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#333'
    },
    density: 0.002,
    friction: 0.5
  });
  const lowerLeftLeg = Bodies.rectangle(x - 10, y + 65, 6, 20, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#333'
    },
    density: 0.002,
    friction: 0.5
  });
  const upperRightLeg = Bodies.rectangle(x + 10, y + 50, 8, 20, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#333'
    },
    density: 0.002,
    friction: 0.5
  });
  const lowerRightLeg = Bodies.rectangle(x + 10, y + 65, 6, 20, {
    collisionFilter: {
      group
    },
    render: {
      fillStyle: '#333'
    },
    density: 0.002,
    friction: 0.5
  });
  const constraints = [Matter.Constraint.create({
    bodyA: head,
    bodyB: torso,
    pointA: {
      x: 0,
      y: 15
    },
    pointB: {
      x: 0,
      y: -20
    },
    stiffness: 0.95,
    damping: 0.5,
    render: {
      visible: false
    }
  }), Matter.Constraint.create({
    bodyA: torso,
    bodyB: pelvis,
    stiffness: 0.95,
    damping: 0.5,
    render: {
      visible: false
    }
  }), Matter.Constraint.create({
    bodyA: torso,
    bodyB: upperLeftArm,
    pointA: {
      x: -15,
      y: -15
    },
    stiffness: 0.8,
    damping: 0.5,
    render: {
      visible: false
    }
  }), Matter.Constraint.create({
    bodyA: upperLeftArm,
    bodyB: lowerLeftArm,
    stiffness: 0.8,
    damping: 0.5,
    render: {
      visible: false
    }
  }), Matter.Constraint.create({
    bodyA: torso,
    bodyB: upperRightArm,
    pointA: {
      x: 15,
      y: -15
    },
    stiffness: 0.8,
    damping: 0.5,
    render: {
      visible: false
    }
  }), Matter.Constraint.create({
    bodyA: upperRightArm,
    bodyB: lowerRightArm,
    stiffness: 0.8,
    damping: 0.5,
    render: {
      visible: false
    }
  }), Matter.Constraint.create({
    bodyA: pelvis,
    bodyB: upperLeftLeg,
    pointA: {
      x: -10,
      y: 0
    },
    stiffness: 0.8,
    damping: 0.5,
    render: {
      visible: false
    }
  }), Matter.Constraint.create({
    bodyA: upperLeftLeg,
    bodyB: lowerLeftLeg,
    stiffness: 0.8,
    damping: 0.5,
    render: {
      visible: false
    }
  }), Matter.Constraint.create({
    bodyA: pelvis,
    bodyB: upperRightLeg,
    pointA: {
      x: 10,
      y: 0
    },
    stiffness: 0.8,
    damping: 0.5,
    render: {
      visible: false
    }
  }), Matter.Constraint.create({
    bodyA: upperRightLeg,
    bodyB: lowerRightLeg,
    stiffness: 0.8,
    damping: 0.5,
    render: {
      visible: false
    }
  })];
  const allParts = [head, torso, pelvis, upperLeftArm, lowerLeftArm, upperRightArm, lowerRightArm, upperLeftLeg, lowerLeftLeg, upperRightLeg, lowerRightLeg];
  Matter.Events.on(engine, 'beforeUpdate', () => {
    Body.applyForce(torso, torso.position, {
      x: 0,
      y: -0.0002
    });
    allParts.forEach(part => {
      Body.setAngularVelocity(part, part.angularVelocity * 0.95);
    });
    const targetAngle = 0;
    const correction = targetAngle - pelvis.angle;
    Body.setAngularVelocity(pelvis, correction * 0.05);
  });
  Composite.add(engine.world, [...allParts, ...constraints]);
}

function createLightningBolt(x, y) {
  const worldPos = Matter.Vector.create(x / render.options.pixelRatio, y / render.options.pixelRatio);
  const zigs = 8;
  const zigLength = 40;
  const zigWidth = 8;
  let prevX = worldPos.x;
  let prevY = worldPos.y;
  const group = Body.nextGroup(true);
  const points = [{
    x,
    y
  }];
  for (let i = 1; i <= zigs; i++) {
    points.push({
      x: x + (Math.random() - 0.5) * 30,
      y: y + i * zigLength
    });
  }
  for (let i = 0; i < points.length - 1; i++) {
    const start = points[i];
    const end = points[i + 1];
    const angle = Math.atan2(end.y - start.y, end.x - start.x);
    const length = Vector.magnitude(Vector.sub(end, start));
    const body = Bodies.rectangle((start.x + end.x) / 2, (start.y + end.y) / 2, length, zigWidth, {
      angle: angle,
      render: {
        fillStyle: '#ffff00',
        strokeStyle: '#ffffff',
        lineWidth: 1
      },
      collisionFilter: {
        group
      },
      isSensor: true
    });
    const angle2 = Math.atan2(end.y - start.y, end.x - start.x);
    Body.rotate(body, angle2);
    Composite.add(engine.world, body);
    for (let j = 0; j < 3; j++) {
      const particle = Bodies.circle(body.position.x + (Math.random() - 0.5) * 10, body.position.y + (Math.random() - 0.5) * 10, 2, {
        render: {
          fillStyle: '#ffffff80'
        },
        collisionFilter: {
          group
        }
      });
      Composite.add(engine.world, particle);
    }
    prevX += (Math.random() - 0.5) * 40;
    prevY = end.y;
  }
  setTimeout(() => {
    const bodies = Composite.allBodies(engine.world);
    bodies.forEach(body => {
      if (body.collisionFilter.group === group) {
        Composite.remove(engine.world, body);
      }
    });
  }, 1000);
}

function createCannon(x, y) {
  const base = Bodies.rectangle(x, y, 60, 30, {
    isStatic: true,
    render: {
      fillStyle: '#666',
      strokeStyle: '#333',
      lineWidth: 2
    }
  });
  const barrel = Bodies.rectangle(x + 30, y - 10, 60, 20, {
    isStatic: true,
    render: {
      fillStyle: '#444',
      strokeStyle: '#222',
      lineWidth: 1
    }
  });
  const pivot = Matter.Constraint.create({
    bodyA: base,
    bodyB: barrel,
    pointA: {
      x: 20,
      y: -10
    },
    stiffness: 0.8,
    render: {
      visible: false
    }
  });
  Composite.add(engine.world, [base, barrel, pivot]);
  barrel.canFire = true;
  Matter.Events.on(mouseConstraint, 'mousedown', () => {
    if (Matter.Bounds.contains(barrel.bounds, mouse.position) && barrel.canFire) {
      const angle = barrel.angle;
      const force = 0.02;
      const ball = Bodies.circle(barrel.position.x + 40 * Math.cos(angle), barrel.position.y + 40 * Math.sin(angle), 10, {
        render: {
          fillStyle: '#000'
        },
        friction: 0.05,
        restitution: 0.6,
        density: 0.002
      });
      Composite.add(engine.world, ball);
      Body.applyForce(ball, ball.position, {
        x: Math.cos(angle) * force,
        y: Math.sin(angle) * force
      });
      barrel.canFire = false;
      setTimeout(() => barrel.canFire = true, 1000);
    }
  });
  return base;
}

function handleCollisions(event) {
  event.pairs.forEach(pair => {
    const {
      bodyA,
      bodyB
    } = pair;
    if (bodyA.render.fillStyle === '#00f4' || bodyB.render.fillStyle === '#00f4') {
      const liquidBody = bodyA.render.fillStyle === '#00f4' ? bodyA : bodyB;
      const otherBody = liquidBody === bodyA ? bodyB : bodyA;
      const relativeVelocity = Vector.magnitude(Vector.sub(bodyA.velocity, bodyB.velocity));
      if (relativeVelocity > 10) {
        const numParticles = Math.min(2, Math.floor(relativeVelocity / 4));
        for (let i = 0; i < numParticles; i++) {
          const splashParticle = Bodies.circle(liquidBody.position.x + (Math.random() - 0.5) * 8, liquidBody.position.y + (Math.random() - 0.5) * 8, PARTICLE_SIZE / 2, {
            render: {
              fillStyle: '#00f4'
            },
            density: LIQUID_DENSITY / 2,
            friction: LIQUID_FRICTION,
            frictionAir: LIQUID_FRICTION_AIR * 2,
            restitution: LIQUID_RESTITUTION,
            lifespan: 100
          });
          Body.setVelocity(splashParticle, {
            x: (Math.random() - 0.5) * relativeVelocity * 0.8,
            y: -relativeVelocity * 0.4
          });
          Composite.add(engine.world, splashParticle);
          setTimeout(() => {
            Composite.remove(engine.world, splashParticle);
          }, 300);
        }
      }
    }
  });
}

function handleBeforeUpdate() {
  const bodies = Composite.allBodies(engine.world);
  bodies.forEach(body => {
    if (body.render && body.render.fillStyle && body.render.fillStyle.includes('#ff')) {
      Body.applyForce(body, body.position, {
        x: 0,
        y: -0.0001
      });
    }
  });
}

Matter.Events.on(engine, 'collisionStart', handleCollisions);
Matter.Events.on(engine, 'beforeUpdate', handleBeforeUpdate);

render.canvas.addEventListener('mousedown', event => {
  const type = document.getElementById('effectsSelect').value;
  if (!type) return;
  let activeEffect = type;
  const handleEffect = (x, y) => {
    if (activeEffect === 'lightning_bolt') {
      createLightningBolt(x, y);
    } else if (activeEffect === 'fire_source') {
      for (let i = 0; i < 3; i++) {
        createFireParticle(x, y);
      }
    }
  };
  handleEffect(event.clientX, event.clientY);
  let effectInterval = setInterval(() => {
    handleEffect(event.clientX, event.clientY);
  }, activeEffect === 'lightning_bolt' ? 100 : 20);
});

render.canvas.addEventListener('touchstart', event => {
  event.preventDefault();
  const touch = event.touches[0];
  const type = document.getElementById('effectsSelect').value;
  if (!type) return;
  let activeEffect = type;
  const handleEffect = (x, y) => {
    if (activeEffect === 'lightning_bolt') {
      createLightningBolt(x, y);
    } else if (activeEffect === 'fire_source') {
      for (let i = 0; i < 3; i++) {
        createFireParticle(x, y);
      }
    }
  };
  handleEffect(touch.clientX, touch.clientY);
  let effectInterval = setInterval(() => {
    handleEffect(touch.clientX, touch.clientY);
  }, activeEffect === 'lightning_bolt' ? 100 : 20);
});

render.canvas.addEventListener('touchmove', function (event) {
  event.preventDefault();
  const touch = event.touches[0];
  mouse.position.x = touch.clientX;
  mouse.position.y = touch.clientY;
}, {
  passive: false
});

render.canvas.addEventListener('touchend', event => {
  event.preventDefault();
  if (effectInterval) {
    clearInterval(effectInterval);
    effectInterval = null;
    activeEffect = null;
  }
});

render.canvas.addEventListener('mousemove', event => {
  if (effectInterval) {
    const type = document.getElementById('effectsSelect').value;
    if (type === 'lightning_bolt') {
      createLightningBolt(event.clientX, event.clientY);
    } else if (type === 'fire_source') {
      for (let i = 0; i < 3; i++) {
        createFireParticle(event.clientX, event.clientY);
      }
    }
  }
});

render.canvas.addEventListener('mouseup', () => {
  if (effectInterval) {
    clearInterval(effectInterval);
    effectInterval = null;
    activeEffect = null;
  }
});

render.canvas.addEventListener('mouseleave', () => {
  if (effectInterval) {
    clearInterval(effectInterval);
    effectInterval = null;
    activeEffect = null;
  }
});

Matter.Events.on(mouseConstraint, 'enddrag', function (event) {
  if (event.body) {
    const mousePos = event.mouse.position;
    const mouseDownPos = event.mouse.mousedownPosition;
    const velocityMultiplier = 0.05;
    Body.setVelocity(event.body, {
      x: (mousePos.x - mouseDownPos.x) * velocityMultiplier,
      y: (mousePos.y - mouseDownPos.y) * velocityMultiplier
    });
  }
});

render.canvas.addEventListener('contextmenu', event => {
  event.preventDefault();
  const bodies = Composite.allBodies(engine.world);
  const mousePosition = {
    x: event.clientX,
    y: event.clientY
  };
  bodies.forEach(body => {
    if (!body.isStatic && Matter.Bounds.contains(body.bounds, mousePosition)) {
      Composite.remove(engine.world, body);
    }
  });
});

let lastTime = performance.now();
let frameCount = 0;
let fps = 60;

function updateFPS() {
  const now = performance.now();
  frameCount++;
  
  if (now - lastTime >= 1000) {
    fps = Math.round(frameCount * 1000 / (now - lastTime));
    document.getElementById('fps').textContent = `FPS: ${fps}`;
    frameCount = 0;
    lastTime = now;
  }
  
  if (fps < 30 && engine.timing.timeScale > 0.8) {
    engine.timing.timeScale *= 0.9;
  } else if (fps > 45 && engine.timing.timeScale < 1) {
    engine.timing.timeScale = Math.min(1, engine.timing.timeScale * 1.1);
  }
  
  requestAnimationFrame(updateFPS);
}
updateFPS();

let isDarkTheme = true;

function toggleTheme() {
  document.body.classList.toggle('light-theme');
  isDarkTheme = !isDarkTheme;
  
  render.options.background = isDarkTheme ? '#1a1a1a' : '#f5f5f5';
  
  createThemeChangeParticles();
}

function createThemeChangeParticles() {
  const container = document.querySelector('.particles-container');
  container.innerHTML = '';
  
  for (let i = 0; i < 30; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    
    const size = Math.random() * 10 + 5;
    particle.style.width = size + 'px';
    particle.style.height = size + 'px';
    
    particle.style.left = Math.random() * window.innerWidth + 'px';
    particle.style.top = Math.random() * window.innerHeight + 'px';
    
    particle.style.opacity = Math.random() * 0.5 + 0.2;
    
    const duration = Math.random() * 2 + 1;
    particle.style.animation = `float ${duration}s ease-out forwards`;
    
    container.appendChild(particle);
    
    setTimeout(() => {
      particle.remove();
    }, duration * 1000);
  }
}

const tooltip = document.querySelector('.tooltip');
function showTooltip(text, x, y) {
  tooltip.textContent = text;
  tooltip.style.left = (x + 10) + 'px';
  tooltip.style.top = (y - 30) + 'px';
  tooltip.style.opacity = 1;
}

function hideTooltip() {
  tooltip.style.opacity = 0;
}

render.canvas.addEventListener('mousemove', (event) => {
  if (document.getElementById('objectSelect').value) {
    showTooltip('Click to spawn', event.clientX, event.clientY);
  } else {
    hideTooltip();
  }
});

render.canvas.addEventListener('mouseout', hideTooltip);

const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
if (isMobile) {
  const controls = document.getElementById('controls');
  controls.style.width = '180px';
  controls.style.transform = 'translateX(-160px)';
  
  const showHideTab = document.createElement('div');
  showHideTab.style.position = 'absolute';
  showHideTab.style.right = '-20px';
  showHideTab.style.top = '50%';
  showHideTab.style.width = '20px';
  showHideTab.style.height = '40px';
  showHideTab.style.background = '#4CAF50';
  showHideTab.style.borderRadius = '0 5px 5px 0';
  showHideTab.style.cursor = 'pointer';
  showHideTab.innerHTML = '&raquo;';
  showHideTab.style.display = 'flex';
  showHideTab.style.alignItems = 'center';
  showHideTab.style.justifyContent = 'center';
  
  controls.appendChild(showHideTab);
  
  let controlsVisible = false;
  showHideTab.addEventListener('click', () => {
    controlsVisible = !controlsVisible;
    controls.style.transform = controlsVisible ? 'translateX(0)' : 'translateX(-160px)';
    showHideTab.innerHTML = controlsVisible ? '&laquo;' : '&raquo;';
  });
}

window.addEventListener('resize', () => {
  render.canvas.width = window.innerWidth;
  render.canvas.height = window.innerHeight;
  render.options.width = window.innerWidth;
  render.options.height = window.innerHeight;
  Render.setPixelRatio(render, window.devicePixelRatio || 1);
  
  Composite.clear(engine.world, false, true);
  Composite.add(engine.world, [
    Bodies.rectangle(window.innerWidth / 2, window.innerHeight + 30, window.innerWidth, 60, {
      isStatic: true, restitution: 0.4, friction: 0.8
    }),
    Bodies.rectangle(window.innerWidth / 2, -30, window.innerWidth, 60, {
      isStatic: true, restitution: 0.4, friction: 0.8
    }),
    Bodies.rectangle(-30, window.innerHeight / 2, 60, window.innerHeight, {
      isStatic: true, restitution: 0.4, friction: 0.8
    }),
    Bodies.rectangle(window.innerWidth + 30, window.innerHeight / 2, 60, window.innerHeight, {
      isStatic: true, restitution: 0.4, friction: 0.8
    })
  ]);
  
  recreateMouseConstraint();
});

function recreateMouseConstraint() {
  if (mouseConstraint) {
    Matter.Events.off(mouseConstraint);
    Composite.remove(engine.world, mouseConstraint);
  }
  
  mouse = Mouse.create(render.canvas);
  render.mouse = mouse;
  
  mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: {
      stiffness: 0.2,
      render: {
        visible: false
      },
      angularStiffness: 0.1,
      damping: 0.1
    }
  });
  
  Composite.add(engine.world, mouseConstraint);
  
  Matter.Events.on(engine, 'collisionStart', handleCollisions);
  Matter.Events.on(engine, 'beforeUpdate', handleBeforeUpdate);
}

setInterval(recreateMouseConstraint, 3000);

window.addEventListener('load', () => {
  showUpdateNotes();
  if (isMobile) {
    alert('Tip: Tap the green tab on the left to access controls');
  }
  
  createThemeChangeParticles();
});

function showUpdateNotes() {
  if (hasSeenUpdateNotes) return;
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay';
  const modal = document.createElement('div');
  modal.id = 'updateNotes';
  modal.innerHTML = `
      <h2>📝 Latest Updates</h2>
      <ul>
          <li>✨ Added search functionality for objects</li>
          <li>🎨 Modernized UI design</li>
          <li>🔍 Improved search box interface</li>
          <li>🎮 Enhanced effects selection</li>
          <li>⚡ Added new physics effects</li>
      </ul>
      <button onclick="closeUpdateNotes()">Got it!</button>
  `;
  document.body.appendChild(overlay);
  document.body.appendChild(modal);
  hasSeenUpdateNotes = true;
}

function closeUpdateNotes() {
  const modal = document.getElementById('updateNotes');
  const overlay = document.querySelector('.modal-overlay');
  if (modal) modal.remove();
  if (overlay) overlay.remove();
}

function filterObjects() {
  const searchTerm = document.getElementById('searchBox').value.toLowerCase().trim();
  const select = document.getElementById('objectSelect');
  const searchResults = document.getElementById('searchResults');
  if (!searchTerm) {
    searchResults.style.display = 'none';
    return;
  }
  const options = Array.from(select.options);
  const matches = options.filter(option => {
    const value = option.value.toLowerCase();
    const text = option.textContent.toLowerCase();
    return value.includes(searchTerm) || text.includes(searchTerm);
  });
  if (matches.length > 0) {
    searchResults.innerHTML = matches.map(option => `
                <div class="searchResult" data-value="${option.value}">
                    ${option.textContent}
                </div>
            `).join('');
    searchResults.style.display = 'block';
  } else {
    searchResults.style.display = 'none';
  }
}

document.getElementById('searchBox').addEventListener('input', filterObjects);
document.getElementById('searchBox').addEventListener('keyup', filterObjects);
document.getElementById('searchBox').addEventListener('change', filterObjects);
document.getElementById('searchResults').addEventListener('click', e => {
  if (e.target.classList.contains('searchResult')) {
    const value = e.target.dataset.value;
    document.getElementById('objectSelect').value = value;
    document.getElementById('searchResults').style.display = 'none';
    document.getElementById('searchBox').value = '';
  }
});

document.addEventListener('click', e => {
  const searchResults = document.getElementById('searchResults');
  const searchBox = document.getElementById('searchBox');
  if (!searchResults.contains(e.target) && e.target !== searchBox) {
    searchResults.style.display = 'none';
  }
});

document.querySelectorAll('select').forEach(select => {
  select.addEventListener('focus', e => {
    e.target.style.transform = 'translateY(-2px)';
  });
  select.addEventListener('blur', e => {
    e.target.style.transform = 'translateY(0)';
  });
  select.addEventListener('change', e => {
    e.target.style.transform = 'translateY(0)';
    e.target.style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
    setTimeout(() => {
      e.target.style.backgroundColor = 'rgba(30,30,30,0.95)';
    }, 200);
  });
}

function addAmbientParticles() {
  if (Composite.allBodies(engine.world).length > 100) return; 
  
  const x = Math.random() * window.innerWidth;
  const y = -20;
  
  const particle = Bodies.circle(x, y, Math.random() * 3 + 1, {
    render: {
      fillStyle: isDarkTheme ? '#ffffff10' : '#00000010'
    },
    frictionAir: 0.01,
    density: 0.0001,
    lifespan: 8000
  });
  
  Composite.add(engine.world, particle);
  
  setTimeout(() => {
    Composite.remove(engine.world, particle);
  }, 8000);
}

setInterval(addAmbientParticles, 2000);
</script>
</body></html>